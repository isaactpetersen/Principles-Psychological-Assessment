# Structural Equation Modeling {#sem}

> "All models are wrong, but some are useful."
>
> --- George Box [-@Box1979, p. 202]

## Overview of SEM {#overview-sem}

Structural equation modeling is an advanced modeling approach that allows estimating latent variables to account for [measurement error](#measurementError) and to get purer estimates of constructs.\index{structural equation modeling}\index{measurement error}\index{latent variable}

## Getting Started {#gettingStarted-sem}

### Load Libraries {#loadLibraries-sem}

```{r}
library("petersenlab")
library("lavaan")
library("semTools")
library("semPlot")
library("simsem")
library("snow")
library("mice")
library("quantreg")
library("nonnest2")
library("MOTE")
library("tidyverse")
library("here")
library("tinytex")
```

### Prepare Data {#prepareData-sem}

#### Simulate Data {#simulateData-sem}

For reproducibility, I set the seed below.\index{simulate data}
Using the same seed will yield the same answer every time.
There is nothing special about this particular seed.

The `petersenlab` package [@R-petersenlab] includes a [`complement()` function](https://stats.stackexchange.com/a/313138/20338) (archived at https://perma.cc/S26F-QSW3) that simulates data with a specified correlation in relation to an existing variable.\index{petersenlab package}
`PoliticalDemocracy` refers to the Industrialization and Political Democracy data set from the `lavaan` package [@R-lavaan], and it contains measures of political democracy and industrialization in developing countries.

```{r}
sampleSize <- 300

set.seed(52242)

measure1 <- rnorm(n = sampleSize, mean = 50, sd = 10)
measure2 <- measure1 + rnorm(n = sampleSize, mean = 0, sd = 15)
measure3 <- measure1 + measure2 + rnorm(n = sampleSize, mean = 0, sd = 15)

v1 <- complement(PoliticalDemocracy$y1, .4)
v2 <- complement(PoliticalDemocracy$y1, .4)
v3 <- complement(PoliticalDemocracy$y1, .4)
v4 <- complement(PoliticalDemocracy$y1, .4)

PoliticalDemocracy$v1 <- v1
PoliticalDemocracy$v2 <- v2
PoliticalDemocracy$v3 <- v3
PoliticalDemocracy$v4 <- v4
```

#### Add Missing Data {#addMissingData-sem}

Adding missing data to dataframes helps make examples more realistic to real-life data and helps you get in the habit of programming to account for missing data.

```{r}
measure1[c(5,10)] <- NA
measure2[c(10,15)] <- NA
measure3[c(10)] <- NA
PoliticalDemocracy <- 
  as.data.frame(lapply(
    PoliticalDemocracy,
    function(cc) cc[ sample(
      c(TRUE, NA),
      prob = c(0.9, 0.1),
      size = length(cc),
      replace = TRUE)]))
```

#### Combine data into data frame {#combineData-sem}

```{r}
mydataSEM <- data.frame(measure1, measure2, measure3)
```

## Types of Models {#modelTypes-sem}

### Path Analysis Model {#pathAnalysis-sem}

To understand structural equation modeling (SEM), it is helpful to first understand *path analysis*.\index{path analysis}
Path analysis is similar to multiple regression.\index{path analysis}\index{multiple regression}
Path analysis allows examining the association between multiple predictor variables (or independent variables) in relation to an outcome variable (or dependent variable).\index{path analysis}
Unlike multiple regression, however, path analysis also allows inclusion of multiple *dependent* variables in the same model.\index{path analysis}\index{multiple regression}
Unlike SEM, path analysis uses only manifest (observed) variables, not latent variables (described next).\index{path analysis}\index{structural equation modeling}\index{latent variable}
SEM is path analysis, but with latent (unobserved) variables.\index{structural equation modeling}\index{latent variable}
That is, a SEM model is a model that includes latent variables in addition to observed variables.\index{structural equation modeling}\index{latent variable}

### Components of a Structural Equation Model {#semModelComponents}

#### Measurement Model {#measurementModel-sem}

The measurement model is a crucial sub-component of any SEM model.\index{structural equation modeling!measurement model}
A SEM model consists of two components: a measurement model and a structural model.\index{structural equation modeling!measurement model}
The *measurement model* is a [confirmatory factor analysis](#cfa-sem) (CFA) model that identifies how many latent factors are estimated, and which items load onto which latent factor.\index{structural equation modeling!measurement model}\index{factor analysis!confirmatory}\index{latent variable}
The measurement model can also specify correlated residuals.\index{structural equation modeling!residual!correlated}\index{structural equation modeling!measurement model}
Basically, the measurement model specifies your best understanding of the structure of the latent construct(s) given how they were assessed.\index{structural equation modeling!measurement model}\index{construct}\index{latent variable}
Before fitting the structural component of a SEM, it is important to have a well-fitting measurement model for each construct in the model.\index{structural equation modeling!measurement model}\index{construct}
In Section \@ref(measurementModel-sem), I present an example of a measurement model.\index{structural equation modeling!measurement model}

#### Structural Model {#structuralModel-sem}

The *structural component* of a SEM model includes the regression paths that specify the hypothesized causal relations among the latent variables.\index{structural equation modeling!structural model}\index{latent variable}

### Confirmatory Factor Analysis Model {#cfa-sem}

[Confirmatory factor analysis](#cfa) (CFA) is a subset of SEM.
CFA includes the [measurement model](#measurementModel-sem) but not the [structural component](#structuralModel-sem) of the model.\index{factor analysis!confirmatory}\index{structural equation modeling!measurement model}\index{structural equation modeling!structural model}
In Section \@ref(cfaExample-sem), I present an example of a [CFA](#cfa) model.\index{factor analysis!confirmatory}
I discuss [CFA](#cfa) models in greater depth in Chapter \@ref(factor-analysis-PCA).\index{factor analysis!confirmatory}

### Structural Equation Model {#semModel}

SEM is [CFA](#cfa), but it adds regression paths that specify hypothesized causal relations between the latent variables, which is called the [structural component](#structuralModel-sem) of the model.\index{structural equation modeling}\index{structural equation modeling!structural model}\index{factor analysis!confirmatory}\index{latent variable}
The [structural model](#structuralModel-sem) includes the hypothesized causal relations between latent variables.\index{structural equation modeling!structural model}\index{latent variable}
A SEM model includes both the [measurement model](#measurementModel-sem) and the [structural model](#structuralModel-sem) [see Figure \@ref(fig:measurementModelStructuralModel), @Civelek2018].\index{structural equation modeling}\index{structural equation modeling!measurement model}\index{structural equation modeling!structural model}
SEM fits a model to observed data, or the variance-covariance matrix, and evaluates the degree of model misfit.\index{structural equation modeling}
That is, fit indices evaluate how likely it is that a given model gave rise to the observed data.\index{structural equation modeling!fit index}
In Section \@ref(semModelExample-sem), I present an example of a SEM model.\index{structural equation modeling}

(ref:measurementModelStructuralModelCaption) Demarcation Between Measurement Model and Structural Model. Figure adapted from @Civelek2018, Figure 1, p. 7. Civelek, M. E. (2018). *Essentials of structural equation modeling*. Zea E-Books. [https://doi.org/10.13014/K2SJ1HR5](https://doi.org/10.13014/K2SJ1HR5)

```{r measurementModelStructuralModel, out.width = "100%", fig.align = "center", fig.cap = "(ref:measurementModelStructuralModelCaption)", echo = FALSE}
knitr::include_graphics("./Images/measurementModelStructuralModel.png")
```

SEM is flexible in allowing you to specify [measurement error](#measurementError) and correlated errors.\index{structural equation modeling}\index{measurement error}\index{structural equation modeling!residual!correlated}
Thus, you do not need the same assumptions as in [classical test theory](#ctt), which assumes that [errors](#measurementError) are [random](#randomError) and uncorrelated.\index{classical test theory}\index{measurement error}\index{measurement error!random error}
But the flexibility of SEM also poses challenges because you must explicitly decide what to include—and not include—in your model.\index{structural equation modeling}
This flexibility can be both a blessing and a curse.\index{structural equation modeling}
If the model fit is unacceptable, you can try fitting a different model to see which fits better.\index{structural equation modeling}\index{structural equation modeling!fit index}
Nevertheless, it is important to use theory as a guide when specifying and comparing competing models, and not just rely solely on model fit comparison.\index{structural equation modeling}\index{structural equation modeling!fit index}\index{theory}\index{empiricism}
For example, the model you fit should depend on how you conceptualize each construct: as [reflective](#reflectiveConstruct) or [formative](#formativeConstruct).\index{construct!reflective}\index{construct!formative}

## Estimating Latent Factors {#formativeReflective-sem}

### Model Identification {#modelIdentification-sem}

#### Types of Model Identification {#modelIdentificationTypes-sem}

There are important practical issues to consider with both [reflective](#reflectiveConstruct) and [formative](#formativeConstruct) models.\index{construct!reflective}\index{construct!formative}
An important practical issue is model identification—adding enough constraints so that there is only one, best answer.\index{structural equation modeling!model identification}
The model is identified when each of the estimated parameters has a unique solution.\index{structural equation modeling!model identification}

Degrees of freedom in a SEM model is the number of known values minus the number of estimated parameters.\index{structural equation modeling!degrees of freedom}
The number of known values in a SEM model is the number of variances and covariances in the variance-covariance matrix of the manifest (observed) variables in addition to the number of means (i.e., the number of manifest variables), which can be calculated as: $\frac{m(m + 1)}{2} + m$, where $m = \text{the number of manifest variables}$.\index{structural equation modeling!degrees of freedom}
You can never estimate more parameters than the number of known values.\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
A model with zero degrees of freedom is considered "saturated"—it will have perfect fit because the model estimates as many parameters as there are known values.\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
All things equal (i.e., in terms of model fit with the same number of manifest variables), a model with more degrees of freedom is preferred for its parsimony, because fewer parameters are estimated.\index{structural equation modeling!degrees of freedom}\index{parsimony}

Based on the number of known values compared to the number of estimated parameters, a model can be considered either just identified, under-identified, or over-identified.\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
A *just identified model* is a model in which the number of known values is equal to the number of parameters to be estimated (degrees of freedom = 0).\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
An *under-identified model* is a model in which the number of known values is less than the number of parameters to be estimated (degrees of freedom < 0).\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
An *over-identified model* is a model in which the number of number of known values is greater than the number of parameters to be estimated (degrees of freedom > 0).\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}

As an example, there are 14 known values for a model with 4 manifest variables ($\frac{4(4 + 1)}{2} + 4 = 14$): 4 variances, 6 covariances, and 4 means.\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}

Here is the variance-covariance matrix:

```{r}
vcovMatrix4measures <- cov(
  PoliticalDemocracy[,c("y1","y2","y3","y4")],
  use = "pairwise.complete.obs")

vcovMatrix4measures[upper.tri(vcovMatrix4measures)] <- NA

vcovMatrix4measures
```

Here are the variances:

```{r}
variances4measures <- diag(vcovMatrix4measures)

variances4measures
```

Here are the covariances:

```{r}
covariances4measures <- vcovMatrix4measures[lower.tri(vcovMatrix4measures)]

covariances4measures
```

Here are the means:

```{r}
means4Measures <- apply(
  PoliticalDemocracy[,c("y1","y2","y3","y4")],
  2, mean, na.rm = TRUE)

means4Measures
```

#### Approaches to Model Identification {#modelIdentificationApproaches-sem}

The three most widely used approaches to identifying latent factors are:\index{structural equation modeling!model identification}\index{latent variable}

1. [Marker variable](#markerVariable-sem)\index{structural equation modeling!model identification}
1. [Effects coding](#effectsCoding-sem)\index{structural equation modeling!model identification}
1. [Standardized latent factor](#standardizedLatent-sem)\index{structural equation modeling!model identification}

##### Marker Variable Method {#markerVariable-sem}

In the marker variable method, one of the indicators (i.e., manifest variables) is set to have a loading of 1.\index{structural equation modeling!model identification}
Here are examples of using the marker variable method for identification of a latent variable:\index{structural equation modeling!model identification}

```{r}
markerVariable_syntax <- '
 #Factor loadings
 latentFactor =~ y1 + y2 + y3 + y4
'

markerVariable_fullSyntax <- '
 #Factor loadings
 latentFactor =~ 1*y1 + y2 + y3 + y4
 
 #Latent variance
 latentFactor ~~ latentFactor
 
 #Estimate residual variances of manifest variables
 y1 ~~ y1
 y2 ~~ y2
 y3 ~~ y3
 y4 ~~ y4
 
 #Estimate intercepts of manifest variables
 y1 ~ 1
 y2 ~ 1
 y3 ~ 1
 y4 ~ 1
'

markerVariableModelFit <- sem(
  markerVariable_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")

markerVariableModelFit_full <- lavaan(
  markerVariable_fullSyntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")
```

```{r markerVariable, out.width = "100%", fig.align = "center", fig.cap = "Identifying a Latent Variable Using the Marker Variable Approach."}
semPaths(
  markerVariableModelFit,
  what = "est",
  layout = "tree2",
  edge.label.cex = 0.8)
```

##### Effects Coding Method {#effectsCoding-sem}

In the effects coding method, the average of the factor loadings is set to be 1.\index{structural equation modeling!model identification}
The effects coding method is useful if you are interested in the means or variances of the latent factor, because the metric of the latent factor is on the metric of the indicators.\index{structural equation modeling!model identification}
Here are examples of using the effects coding method for identification of a latent variable:\index{structural equation modeling!model identification}

```{r}
effectsCoding_abbreviatedSyntax <- '
 #Factor loadings
 latentFactor =~ y1 + y2 + y3 + y4
'

effectsCoding_syntax <- '
 #Factor loadings
 latentFactor =~ NA*y1 + label1*y1 + label2*y2 + label3*y3 + label4*y4
 
 #Constrain factor loadings
 label1 == 4 - label2 - label3 - label4 # 4 = number of indicators
'

effectsCoding_fullSyntax <- '
 #Factor loadings
 latentFactor =~ label1*y1 + label2*y2 + label3*y3 + label4*y4
 
 #Constrain factor loadings
 label1 == 4 - label2 - label3 - label4 # 4 = number of indicators
 
 #Latent variance
 latentFactor ~~ latentFactor
 
 #Estimate residual variances of manifest variables
 y1 ~~ y1
 y2 ~~ y2
 y3 ~~ y3
 y4 ~~ y4
 
 #Estimate intercepts of manifest variables
 y1 ~ 1
 y2 ~ 1
 y3 ~ 1
 y4 ~ 1
'

effectsCodingModelFit_abbreviated <- sem(
  effectsCoding_abbreviatedSyntax,
  data = PoliticalDemocracy,
  effect.coding = "loadings",
  missing = "ML",
  estimator = "MLR")

effectsCodingModelFit <- sem(
  effectsCoding_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")

effectsCodingModelFit_full <- lavaan(
  effectsCoding_fullSyntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")
```

```{r effectsCoding, out.width = "100%", fig.align = "center", fig.cap = "Identifying a Latent Variable Using the Effects Coding Approach."}
semPaths(
  effectsCodingModelFit,
  what = "est",
  layout = "tree2",
  edge.label.cex = 0.8)
```

##### Standardized Latent Factor Method {#standardizedLatent-sem}

In the standardized latent factor method, the latent factor is set to have a mean of 0 and a standard deviation of 1.\index{structural equation modeling!model identification}
The standardized latent factor method is a useful approach if you are not interested in the means or variances of the latent factors and want to freely estimate the factor loadings.\index{structural equation modeling!model identification}
Here are examples of using the standardized latent factor method for identification of a latent variable:\index{structural equation modeling!model identification}

```{r}
standardizedLatent_abbreviatedsyntax <- '
 #Factor loadings
 latentFactor =~ y1 + y2 + y3 + y4
'

standardizedLatent_syntax <- '
 #Factor loadings
 latentFactor =~ NA*y1 + y2 + y3 + y4
 
 #Latent mean
 latentFactor ~ 0
 
 #Latent variance
 latentFactor ~~ 1*latentFactor
'

standardizedLatent_fullSyntax <- '
 #Factor loadings
 latentFactor =~ NA*y1 + y2 + y3 + y4
 
 #Latent mean
 latentFactor ~ 0
 
 #Latent variance
 latentFactor ~~ 1*latentFactor
 
 #Estimate residual variances of manifest variables
 y1 ~~ y1
 y2 ~~ y2
 y3 ~~ y3
 y4 ~~ y4
 
 #Estimate intercepts of manifest variables
 y1 ~ 1
 y2 ~ 1
 y3 ~ 1
 y4 ~ 1
'

standardizedLatentFit_abbreviated <- sem(
  standardizedLatent_abbreviatedsyntax,
  data = PoliticalDemocracy,
  std.lv = TRUE,
  missing = "ML",
  estimator = "MLR")

standardizedLatentFit <- sem(
  standardizedLatent_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")

standardizedLatentFit_full <- lavaan(
  standardizedLatent_fullSyntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")
```

```{r standaredizedLatent, out.width = "100%", fig.align = "center", fig.cap = "Identifying a Latent Variable Using the Standardized Latent Factor Approach."}
semPaths(
  standardizedLatentFit,
  what = "est",
  layout = "tree2",
  edge.label.cex = 0.8)
```

### Types of Latent Factors {#latentFactorTypes-sem}

#### Reflective Latent Factors {#reflectiveFactors-sem}

For a [reflective model](#reflectiveConstruct) with 4 indicators, we would need to estimate 12 parameters: a factor loading, error term, and intercept for each of the 4 indicators.\index{construct!reflective}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
Here are the parameters estimated:

```{r}
reflectiveModel_syntax <- '
 #Reflective model factor loadings
 reflective =~ y1 + y2 + y3 + y4
'

reflectiveModelFit <- sem(
  reflectiveModel_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR",
  std.lv = TRUE)

reflectiveModelParameters <- parameterEstimates(
  reflectiveModelFit)[!is.na(parameterEstimates(reflectiveModelFit)$z),]

row.names(reflectiveModelParameters) <- NULL

reflectiveModelParameters
```

Here are the degrees of freedom:\index{structural equation modeling!degrees of freedom}

```{r}
fitMeasures(reflectiveModelFit, "df")
```

Here is a model diagram:

```{r reflectiveModelFigure, out.width = "100%", fig.align = "center", fig.cap = "Depiction of a Reflective Model."}
semPaths(
  reflectiveModelFit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 0.8)
```

Thus, for a [reflective model](#reflectiveConstruct), we only have to estimate a small number of parameters to specify what is happening in our model, so the model is parsimonious.\index{construct!reflective}\index{structural equation modeling!degrees of freedom}
With 4 indicators, the number of known values (14) is greater than the number of parameters (12).\index{construct!reflective}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
We have two degrees of freedom ($14 - 12 = 2$).\index{construct!reflective}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
Because the degrees of freedom is greater than zero, it is easy to identify the model—the model is over-identified.\index{construct!reflective}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
A [reflective model](#reflectiveConstruct) with 3 indicators would have 9 known values ($\frac{3(3 + 1)}{2} + 3 = 9$), 9 parameters (3 factor loadings, 3 error terms, 3 intercepts), and 0 degrees of freedom, and it would be identifiable because it would be just-identified.\index{construct!reflective}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}

#### Formative Latent Factors {#formativeFactors-sem}

However, for a [formative model](#formativeConstruct), we must specify more parameters: a factor loading, intercept, and variance for each of the 4 indicators, all 6 permissive correlations, and 1 error term for the latent variable, for a total of 19 parameters.\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
Here are the parameters estimated:

```{r, error = TRUE}
formativeModel_syntax <- '
 #Formative model factor loadings
 formative <~ v1 + v2 + v3 + v4
 
 formative ~~ formative
'

formativeModelFit <- sem(
  formativeModel_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")

formativeModelParameters <- parameterEstimates(formativeModelFit)

formativeModelParameters
```

Here are the degrees of freedom:\index{structural equation modeling!degrees of freedom}

```{r}
formativeModelFit
```

Here is a model diagram:

```{r formativeModelUnderidentifiedFigure, out.width = "100%", fig.align = "center", fig.cap = "Depiction of an Under-Identified Formative Model."}
semPaths(
  formativeModelFit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 0.8)
```

For a [formative model](#formativeConstruct) with 4 measures, the number of known values (14) is less than the number of parameters (19).\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
The number of degrees of freedom is negative ($14 - 19 = -5$), thus the model is not able to be identified—the model is under-identified.\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}

Thus, for a [formative model](#formativeConstruct), we need more parameters than we have data—the model is under-identified.\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
Therefore, to estimate a formative model with 4 indicators, we must add assumptions and other variables that are consequences of the [formative construct](#formativeConstruct).\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
Options for identifying a [formative construct](#formativeConstruct) are described by @Treiblmaier2011.\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
See below for an example formative model that is identified because of additional assumptions.\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}

```{r formativeModelIdentifiedFigure, out.width = "100%", fig.align = "center", fig.cap = "Depiction of an Identified Formative Model."}
formativeModel2_syntax <- '
 #Formative model factor loadings
 formative <~ 1*v1 + v2 + v3 + v4
 reflective =~ y1 + y2 + y3 + y4
 
 formative ~~ 1*formative
 reflective ~ formative
'

formativeModel2Fit <- sem(
  formativeModel2_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")

formativeModel2Parameters <- parameterEstimates(formativeModel2Fit)
formativeModel2Parameters

fitMeasures(formativeModel2Fit, "df")

semPaths(
  formativeModel2Fit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 0.8)
```

Thus, [formative constructs](#formativeConstruct) are challenging to use in a SEM framework.\index{construct!formative}\index{structural equation modeling!model identification}
To estimate a [formative construct](#formativeConstruct) in a SEM framework, the [formative construct](#formativeConstruct) must be used in the context of a model that allows some constraints.\index{construct!formative}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}

## Additional Types of SEM {#additionalSEMmodels}

Up to this point, we have discussed SEM with dimensional constructs.\index{dimensional}
It also worth knowing about additional types of SEM models, including latent class models and mixture models, that handle categorical constructs.\index{categorical}\index{latent class model}\index{mixture model}
However, most disorders are more accurately conceptualized as dimensional than as categorical [@Markon2011], so just because you can estimate categorical latent factors does not necessarily mean that one should.\index{dimensional}\index{categorical}\index{latent class model}\index{mixture model}

### Latent Class Models {#latentClassModels}

In *latent class models*, the construct is not dimensional, but rather categorical.\index{categorical}\index{latent class model}\index{dimensional}
The categorical constructs are latent classifications and are called latent classes.\index{categorical}\index{latent class model}
For instance, the construct could be a diagnosis that influences scores on the measures.\index{categorical}\index{latent class model}\index{diagnosis}
Latent class models examine qualitative differences in kind, rather than quantitative differences in degree.\index{categorical}\index{latent class model}\index{diagnosis}

### Mixture Models {#MixtureModels}

*Mixture models* allow for a combination of latent categorical constructs (classes) and latent dimensional constructs.\index{dimensional}\index{categorical}\index{mixture model}
That is, it allows for both qualitative and quantitative differences.\index{dimensional}\index{categorical}\index{mixture model}
However, this additional model complexity also necessitates a larger sample size for estimation.\index{mixture model}
SEM generally requires a 3-digit sample size ($N = 100+$), whereas mixture models typically require a 4- or 5-digit sample size ($N = 1,000+$).\index{mixture model}

### Exploratory Structural Equation Models {#esemModels}

We describe exploratory structural equation models in Section \@ref(efa-cfa-esem).\index{structural equation modeling!exploratory}

## Model Fit Indices {#modelFitIndices-sem}

Various model fit indices can be used for evaluating how well a model fits the data and for comparing the fit of two competing models.\index{structural equation modeling!fit index}
Fit indices known as absolute fit indices compare whether the model fits better than the best-possible fitting model (i.e., a saturated model).\index{structural equation modeling!fit index}
Examples of absolute fit indices include the chi-square test, root mean square error of approximation (RMSEA), and the standardized root mean square residual (SRMR).\index{structural equation modeling!fit index}

The chi-square test evaluates whether the model has a significant degree of misfit relative to the best-possible fitting model (a saturated model that fits as many parameters as possible; i.e., as many parameters as there are degrees of freedom); the null hypothesis of a chi-square test is that there is no difference between the predicted data (i.e., the data that would be observed if the model were true) and the observed data.\index{structural equation modeling!fit index}
Thus, a non-significant chi-square test indicates good model fit.\index{structural equation modeling!fit index}
However, the chi-square test is sensitive to sample size, and a large sample will likely detect small differences as significantly worse than the best-possible fitting model.\index{structural equation modeling!fit index}

RMSEA is an index of absolute fit.\index{structural equation modeling!fit index}
Lower values indicate better fit.\index{structural equation modeling!fit index}

SRMR is an index of absolute fit with no penalty for model complexity.\index{structural equation modeling!fit index}
Lower values indicate better fit.\index{structural equation modeling!fit index}

There are also various fit indices known as incremental, comparative, or relative fit indices that compare whether the model fits better than the worst-possible fitting model (i.e., a "baseline" or "null" model).\index{structural equation modeling!fit index}
Incremental fit indices include a chi-square difference test, the comparative fit index (CFI), and the Tucker-Lewis Index (TLI).\index{structural equation modeling!fit index}
Unlike the chi-square test comparing the model to the best-possible fitting model, a significant chi-square test of the relative fit index indicates better fit—i.e., that the model fits better than the worst-possible fitting model.\index{structural equation modeling!fit index}

CFI is another relative fit index that compares the model to the worst-possible fitting model.\index{structural equation modeling!fit index}
Higher values indicate better fit.\index{structural equation modeling!fit index}

TLI is another relative fit index.\index{structural equation modeling!fit index}
Higher values indicate better fit.\index{structural equation modeling!fit index}

Parsimony fit include fit indices that use information criteria fit indices, including the Akaike Information Criterion (AIC) and the Bayesian Information Criterion (BIC).\index{structural equation modeling!fit index}\index{parsimony}
Lower AIC values indicate better fit.\index{structural equation modeling!fit index}
BIC penalizes model complexity more so than AIC.\index{structural equation modeling!fit index}
Lower values indicate better fit.\index{structural equation modeling!fit index}

Chi-square difference tests and CFI can be used to compare two nested models.\index{structural equation modeling!fit index}
AIC and BIC can be used to compare two non-nested models.\index{structural equation modeling!fit index}

Criteria for acceptable fit and good fit of SEM models are in Table \@ref(tab:semFitIndices).\index{structural equation modeling!fit index}

Table: (\#tab:semFitIndices) Criteria for Acceptable and Good Fit of Structural Equation Models Based on Fit Indices.

| SEM Fit Index | Acceptable Fit | Good Fit   |
|---------------|----------------|------------|
| RMSEA         | $\leq$ .08     | $\leq$ .05 |
| CFI           | $\geq$ .90     | $\geq$ .95 |
| TLI           | $\geq$ .90     | $\geq$ .95 |
| SRMR          | $\leq$ .10     | $\leq$ .08 |

However, good model fit does not necessarily indicate a true model.\index{structural equation modeling!fit index}

In addition to fit indices, it can be helpful to examine model correlation residuals.\index{structural equation modeling!fit index}\index{structural equation modeling!residual}
Correlation residuals greater than |.10| are possible evidence for poor local fit [@Kline2023].\index{structural equation modeling!fit index}\index{structural equation modeling!residual}
If a correlation residual is positive, it suggests that the model underpredicts the observed association between the two variables.\index{structural equation modeling!fit index}\index{structural equation modeling!residual}
If a correlation residual is negative, it suggests that the model overpredicts their observed association between the two variables.\index{structural equation modeling!fit index}\index{structural equation modeling!residual}
If the two variables are connected by only indirect pathways, it may be helpful to respecify the model with direct pathways between the two variables, such as a direct effect (i.e., regression path) or a covariance path.\index{structural equation modeling!fit index}\index{structural equation modeling!residual}

## Correlation Matrix {#correlationMatrix-sem}

```{r}
cor(mydataSEM, use = "pairwise.complete.obs")
```

Here are correlation matrices of various types using the `cor.table()` function from the `petersenlab` package [@R-petersenlab]:\index{petersenlab package}

```{r}
cor.table(mydataSEM, dig = 2)
cor.table(mydataSEM, type = "manuscript", dig = 2)
cor.table(mydataSEM, type = "manuscriptBig", dig = 2)
```

## Measurement Model {#measurementModelExample-sem}

Even though [measurement models](#measurementModel-sem) are [CFA models](#cfa), I provide separate examples of a [measurement model](#measurementModel-sem) and [CFA models](#cfa) in my examples because [CFA](#cfa) is often used to test competing factor structures.\index{structural equation modeling!measurement model}\index{factor analysis!confirmatory}
For instance, you could use [CFA](#cfa) to test whether the variance in several measures' scores is best explained with one factor or two factors.\index{factor analysis!confirmatory}
In the [measurement model](#measurementModel-sem) below, I present a simple one-factor model with three measures.\index{structural equation modeling!measurement model}
The [measurement model](#measurementModel-sem) is what we settle on as the estimation of each construct before we add the [structural component](#structuralModel-sem) to estimate the relations among latent variables.\index{structural equation modeling!measurement model}\index{structural equation modeling!structural model}
Basically, we add the [structural component](#structuralModel-sem) onto the [measurement model](#measurementModel-sem).\index{structural equation modeling!measurement model}\index{structural equation modeling!structural model}
In Section \@ref(cfaExample-sem), I present a [CFA model](#cfa) with multiple latent factors.\index{factor analysis!confirmatory}

The measurement models were fit in the `lavaan` package [@R-lavaan].\index{structural equation modeling!measurement model}

### Specify the model {#measurementModelSyntax-sem}

```{r}
measurementModel_syntax <- '
 #Factor loadings
 latentFactor =~ measure1 + measure2 + measure3
'

measurementModel_fullSyntax <- '
 #Factor loadings (free the factor loading of the first indicator)
 latentFactor =~ NA*measure1 + measure2 + measure3
 
 #Fix latent mean to zero
 latentFactor ~ 0
 
 #Fix latent variance to one
 latentFactor ~~ 1*latentFactor

 #Estimate covariances among latent variables (not applicable because there is only one latent variable)
 
 #Estimate residual variances of manifest variables
 measure1 ~~ measure1
 measure2 ~~ measure2
 measure3 ~~ measure3
 
 #Free intercepts of manifest variables
 measure1 ~ int1*1
 measure2 ~ int2*1
 measure3 ~ int3*1
'
```

#### Summary of Model Features {#measurementModelSummary-sem}

```{r}
summary(measurementModel_syntax)
summary(measurementModel_fullSyntax)
```

#### Model Syntax in Table Form: {#measurementModelTabular-sem}

```{r}
lavaanify(measurementModel_syntax)
lavaanify(measurementModel_fullSyntax)
```

### Fit the model {#measurementModelFit-sem}

```{r}
measurementModelFit <- cfa(
  measurementModel_syntax,
  data = mydataSEM,
  missing = "ML",
  estimator = "MLR",
  std.lv = TRUE)

measurementModelFit_full <- lavaan(
  measurementModel_fullSyntax,
  data = mydataSEM,
  missing = "ML",
  estimator = "MLR")
```

### Display summary output {#measurementModelOutput-sem}

```{r, include = FALSE}
measurementModelParameters <- parameterEstimates(
  measurementModelFit,
  standardized = TRUE)

measurementModelParameters_beta1 <- measurementModelParameters[
  which(
    measurementModelParameters$lhs == "latentFactor" & 
      measurementModelParameters$rhs == "measure1"),
  "std.all"]

measurementModelParameters_beta2 <- measurementModelParameters[
  which(
    measurementModelParameters$lhs == "latentFactor" & 
      measurementModelParameters$rhs == "measure2"),
  "std.all"]

measurementModelParameters_beta3 <- measurementModelParameters[
  which(
    measurementModelParameters$lhs == "latentFactor" & 
      measurementModelParameters$rhs == "measure3"),
  "std.all"]
```

This measurement model with three indicators is just-identified—the number of parameters estimated is equal to the number of known values, thus leaving zero degrees of freedom.\index{structural equation modeling!measurement model}\index{structural equation modeling!model identification}\index{structural equation modeling!degrees of freedom}
In the model, all three indicators load strongly on the latent factor (measure 1: $\beta = `r apa(measurementModelParameters_beta1, 2)`$; measure 2: $\beta = `r apa(measurementModelParameters_beta2, 2)`$; measure 3: $\beta = `r apa(measurementModelParameters_beta3, 2)`$).\index{structural equation modeling!factor loading}
Thus, the loadings of this measurement model would be consistent with a [reflective latent construct](#reflectiveConstruct).\index{structural equation modeling!measurement model}\index{structural equation modeling!factor loading}\index{construct!reflective}
In terms of interpretation, all three indicators loaded positively on the latent factor, so higher levels of the latent factor are indicated by higher levels on the indicators.\index{structural equation modeling!measurement model}\index{structural equation modeling!factor loading}
However, one of the estimated observed variances is negative, so the model is not able to be estimated accurately.
Thus, we would need to make additional adjustments in order to estimate the model.

```{r}
summary(
  measurementModelFit,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)

summary(
  measurementModelFit_full,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)
```

### Estimates of model fit {#measurementModelFitCriteria-sem}

You can extract specific fit indices using the following syntax:\index{structural equation modeling!fit index}

```{r}
fitMeasures(
  measurementModelFit,
  fit.measures = c(
    "chisq", "df", "pvalue",
    "chisq.scaled", "df.scaled", "pvalue.scaled",
    "chisq.scaling.factor",
    "baseline.chisq","baseline.df","baseline.pvalue",
    "rmsea", "cfi", "tli", "srmr",
    "rmsea.robust", "cfi.robust", "tli.robust"))
```

Because the model is just-identified, many fit statistics are not able to be estimated.\index{structural equation modeling!model identification}

### Residuals {#measurementModelResiduals-sem}

```{r}
residuals(measurementModelFit, type = "cor")
```

### Modification indices {#measurementModelModIndices-sem}

```{r}
modificationindices(measurementModelFit, sort. = TRUE)
```

### Factor scores {#measurementModelFactorScores-sem}

```{r}
measurementModelFit_factorScores <- lavPredict(measurementModelFit)
```

### Internal Consistency Reliability {#measurementModelReliability-sem}

[Internal consistency reliability](#internalConsistency-reliability) of items composing the latent factors, as quantified by [omega ($\omega$)](#coefficientOmega) and [average variance extracted](#averageVarianceExtracted) (AVE), was estimated using the `semTools` package [@R-semTools].\index{reliability!internal consistency!omega}\index{reliability!internal consistency!average variance extracted}

```{r}
compRelSEM(measurementModelFit)
AVE(measurementModelFit)
```

### Path diagram {#measurementModelPathDiagram-sem}

Below is a path diagram of the model generated using the `semPlot` package [@R-semPlot].

```{r, out.width = "100%", fig.align = "center", fig.cap = "Measurement Model."}
semPaths(
  measurementModelFit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 2)
```

## Confirmatory Factor Analysis (CFA) {#cfaExample-sem}

The [confirmatory factor analysis](#cfa) (CFA) models were fit in the `lavaan` package [@R-lavaan].\index{factor analysis!confirmatory}
The examples were adapted from the `lavaan` documentation: http://lavaan.ugent.be/tutorial/cfa.html (archived at https://perma.cc/GKY3-9YE4)

In this [CFA model](#cfa), we estimate three latent factors with three indicators loading on each latent factor.\index{factor analysis!confirmatory}

### Specify the model {#cfaModelSyntax-sem}

```{r}
cfaModel_syntax <- '
 #Factor loadings
 visual  =~ x1 + x2 + x3
 textual =~ x4 + x5 + x6
 speed   =~ x7 + x8 + x9
'

cfaModel_fullSyntax <- '
 #Factor loadings (free the factor loading of the first indicator)
 visual  =~ NA*x1 + x2 + x3
 textual =~ NA*x4 + x5 + x6
 speed   =~ NA*x7 + x8 + x9
 
 #Fix latent means to zero
 visual ~ 0
 textual ~ 0
 speed ~ 0
 
 #Fix latent variances to one
 visual ~~ 1*visual
 textual ~~ 1*textual
 speed ~~ 1*speed
 
 #Estimate covariances among latent variables
 visual ~~ textual
 visual ~~ speed
 textual ~~ speed
 
 #Estimate residual variances of manifest variables
 x1 ~~ x1
 x2 ~~ x2
 x3 ~~ x3
 x4 ~~ x4
 x5 ~~ x5
 x6 ~~ x6
 x7 ~~ x7
 x8 ~~ x8
 x9 ~~ x9
 
 #Free intercepts of manifest variables
 x1 ~ int1*1
 x2 ~ int2*1
 x3 ~ int3*1
 x4 ~ int4*1
 x5 ~ int5*1
 x6 ~ int6*1
 x7 ~ int7*1
 x8 ~ int8*1
 x9 ~ int9*1
'
```

#### Model Syntax in Table Form: {#cfaModelTabular-sem}

```{r}
lavaanify(cfaModel_syntax)
lavaanify(cfaModel_fullSyntax)
```

### Fit the model {#cfaModelFit-sem}

```{r}
cfaModelFit <- cfa(
  cfaModel_syntax,
  data = HolzingerSwineford1939,
  missing = "ML",
  estimator = "MLR",
  std.lv = TRUE)

cfaModelFit_full <- lavaan(
  cfaModel_fullSyntax,
  data = HolzingerSwineford1939,
  missing = "ML",
  estimator = "MLR")
```

### Display summary output {#cfaModelOutput-sem}

In this model, all nine indicators load strongly on their respective latent factor.\index{structural equation modeling!factor loading}
Thus, this measurement model would be defensible.\index{structural equation modeling!measurement model}
In terms of interpretation, all indicators load positively on their respective latent factor, so higher levels of the latent factor are indicated by higher levels on the indicators.\index{structural equation modeling!factor loading}

```{r}
summary(
  cfaModelFit,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)

summary(
  cfaModelFit_full,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)
```

### Estimates of model fit {#cfaModelFitCriteria-sem}

According to model fit estimates, the model fit is good according to SRMR and acceptable according to CFI, but the model fit is weaker according to RMSEA and TLI.\index{structural equation modeling!fit index}
Thus, we may want to consider adjustments to improve the model fit.\index{structural equation modeling!fit index}
In general, we want to make decisions regarding what parameters to estimate based on theory in conjunction with empiricism.\index{structural equation modeling!fit index}\index{theory}\index{empiricism}

```{r}
fitMeasures(
  cfaModelFit,
  fit.measures = c(
    "chisq", "df", "pvalue",
    "chisq.scaled", "df.scaled", "pvalue.scaled",
    "chisq.scaling.factor",
    "baseline.chisq","baseline.df","baseline.pvalue",
    "rmsea", "cfi", "tli", "srmr",
    "rmsea.robust", "cfi.robust", "tli.robust"))
```

### Residuals {#cfaModelResiduals-sem}

```{r}
residuals(cfaModelFit, type = "cor")
```

### Modification indices {#cfaModelModIndices-sem}

Modification indices indicate potential additional parameters that could be estimated that would improve model fit.\index{structural equation modeling!fit index}\index{structural equation modeling!modification indices}
For instance, the modification indices below indicate a few additional factor loadings (i.e., cross loadings) or correlated residuals that could substantially improve model fit.\index{structural equation modeling!residual!correlated}\index{cross loading}\index{structural equation modeling!fit index}\index{structural equation modeling!modification indices}
However, it is generally not recommended to blindly estimate additional parameters solely based on modification indices.\index{structural equation modeling!modification indices}
Rather, it is generally advised to consider modification indices in light of theory.\index{structural equation modeling!modification indices}\index{theory}

```{r}
modificationindices(cfaModelFit, sort. = TRUE)
```

### Factor scores {#cfaModelFactorScores-sem}

```{r}
cfaModelFit_factorScores <- lavPredict(cfaModelFit)
```

### Internal Consistency Reliability {#cfaModelReliability-sem}

[Internal consistency reliability](#internalConsistency-reliability) of items composing the latent factors, as quantified by [omega ($\omega$)](#coefficientOmega) and [average variance extracted](#averageVarianceExtracted) (AVE), was estimated using the `semTools` package [@R-semTools].\index{reliability!internal consistency!omega}\index{reliability!internal consistency!average variance extracted}

```{r}
compRelSEM(cfaModelFit)
AVE(cfaModelFit)
```

### Path Diagram {#cfaModelPathDiagram-sem}

Below is a path diagram of the model generated using the `semPlot` package [@R-semPlot].

```{r, out.width = "100%", fig.align = "center", fig.cap = "Confirmatory Factor Analysis Model."}
semPaths(
  cfaModelFit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 0.8)
```

### Modify model based on modification indices {#cfaModelModification-sem}

In the model below, I modified the model based on estimating an additional factor loading (assuming the additional factor loading is theoretically supported).\index{structural equation modeling!modification indices}
This could be supported, for instance, if a given test involves considerable skills in both the visual domain and in speed of processing.
When the same indicator loads simultaneously on two factors, this is called a *cross loading*.\index{cross loading}
Cross loadings can complicate the interpretation of latent factors, as discussed in Section \@ref(factorRotation) of the chapter on [factor analysis](#factor-analysis-PCA).\index{cross loading}

#### Specify the model {#cfaModelModifiedSyntax-sem}

```{r}
cfaModel2_syntax <- '
 #Factor loadings
 textual =~ x4 + x5 + x6
 visual  =~ x1 + x2 + x3 + x9
 speed   =~ x7 + x8 + x9
'

cfaModel2_fullSyntax <- '
 #Factor loadings (free the factor loading of the first indicator)
 textual =~ NA*x4 + x5 + x6
 visual  =~ NA*x1 + x2 + x3 + x9
 speed   =~ NA*x7 + x8 + x9
 
 #Fix latent means to zero
 visual ~ 0
 textual ~ 0
 speed ~ 0
 
 #Fix latent variances to one
 visual ~~ 1*visual
 textual ~~ 1*textual
 speed ~~ 1*speed
 
 #Estimate covariances among latent variables
 visual ~~ textual
 visual ~~ speed
 textual ~~ speed
 
 #Estimate residual variances of manifest variables
 x1 ~~ x1
 x2 ~~ x2
 x3 ~~ x3
 x4 ~~ x4
 x5 ~~ x5
 x6 ~~ x6
 x7 ~~ x7
 x8 ~~ x8
 x9 ~~ x9
 
 #Free intercepts of manifest variables
 x1 ~ int1*1
 x2 ~ int2*1
 x3 ~ int3*1
 x4 ~ int4*1
 x5 ~ int5*1
 x6 ~ int6*1
 x7 ~ int7*1
 x8 ~ int8*1
 x9 ~ int9*1
'
```

#### Fit the model {#cfaModelModifiedFit-sem}

```{r}
cfaModel2Fit <- cfa(
  cfaModel2_syntax,
  data = HolzingerSwineford1939,
  missing = "ML",
  estimator = "MLR",
  std.lv = TRUE)

cfaModel2Fit_full <- lavaan(
  cfaModel2_fullSyntax,
  data = HolzingerSwineford1939,
  missing = "ML",
  estimator = "MLR")
```

#### Display summary output {#cfaModelModifiedOutput-sem}

```{r}
summary(
  cfaModel2Fit,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)

summary(
  cfaModel2Fit_full,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)
```

#### Estimates of model fit {#cfaModelModifiedFitCriteria-sem}

After fitting the additional factor loading, the model fits well according to RMSEA, CFI, and SRMR, and the model fit is acceptable according to TLI.\index{structural equation modeling!fit index}
Thus, this model could be defensible.

```{r}
fitMeasures(
  cfaModel2Fit,
  fit.measures = c(
    "chisq", "df", "pvalue",
    "chisq.scaled", "df.scaled", "pvalue.scaled",
    "chisq.scaling.factor",
    "baseline.chisq","baseline.df","baseline.pvalue",
    "rmsea", "cfi", "tli", "srmr",
    "rmsea.robust", "cfi.robust", "tli.robust"))
```

#### Residuals {#cfaModelModifiedResiduals-sem}

```{r}
residuals(cfaModel2Fit, type = "cor")
```

#### Path diagram {#cfaModelModifiedPathDiagram-sem}

Below is a path diagram of the model generated using the `semPlot` package [@R-semPlot].

```{r, out.width = "100%", fig.align = "center", fig.cap = "Modified Confirmatory Factor Analysis Model."}
semPaths(
  cfaModel2Fit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 0.8)
```

#### Compare model fit {#nestedModelComparison-sem}

The modified model with the cross loading and the original model are considered "nested" models.\index{nested model}\index{cross loading}
The original model is nested within the modified model because the modified model includes all of the terms of the original model along with additional terms.\index{nested model}
Model fit of nested models can be compared with a chi-square difference test.\index{chi-square!difference test}\index{structural equation modeling!model comparison}\index{nested model}

```{r}
anova(cfaModelFit, cfaModel2Fit)
```

In this case, the model with the cross loading fits significantly better (i.e., has a significantly smaller chi-square value) than the model without the cross loading.\index{cross loading}\index{structural equation modeling!model comparison}\index{nested model}

One can also compare nested models using a robust likelihood ratio test:\index{structural equation modeling!model comparison}\index{nested model}

```{r}
cfaModelFitML <- cfa(
  cfaModel_syntax,
  data = HolzingerSwineford1939,
  missing = "ML",
  estimator = "ML",
  std.lv = TRUE)

cfaModel2FitML <- cfa(
  cfaModel2_syntax,
  data = HolzingerSwineford1939,
  missing = "ML",
  estimator = "ML",
  std.lv = TRUE)

vuongtest(
  cfaModelFitML,
  cfaModel2FitML,
  nested = TRUE)
```

For non-nested models, one can compare model fit with AIC, BIC, or the Vuong test.\index{structural equation modeling!model comparison}

```{r}
fitMeasures(
  cfaModelFitML,
  fit.measures = c(
    "aic","bic","bic2"))

fitMeasures(
  cfaModel2FitML,
  fit.measures = c(
    "aic","bic","bic2"))

vuongtest(
  cfaModelFitML,
  cfaModel2FitML,
  nested = FALSE)
```

## Structural Equation Model (SEM) {#semModelExample-sem}

The structural equation models were fit in the `lavaan` package [@R-lavaan].
The examples were adapted from the `lavaan` documentation: http://lavaan.ugent.be/tutorial/sem.html (archived at https://perma.cc/8NG9-7JAG)

In this model, we fit a [measurement model](#measurementModel-sem) with three latent factors in addition to a [structural model](#structuralModel-sem) with regressions estimated among the latent factors.\index{structural equation modeling!measurement model}\index{structural equation modeling!structural model}

### Specify the model {#semModelSyntax-sem}

```{r}
semModel_syntax <- '
 #Measurement model factor loadings
 ind60 =~ x1 + x2 + x3
 dem60 =~ y1 + y2 + y3 + y4
 dem65 =~ y5 + y6 + y7 + y8

 #Regression paths
 dem60 ~ ind60
 dem65 ~ ind60 + dem60
 
 #Covariances among residual variances (correlated errors)
 y1 ~~ y5
 y2 ~~ y4 + y6
 y3 ~~ y7
 y4 ~~ y8
 y6 ~~ y8
'

semModel_fullSyntax <- '
 #Measurement model factor loadings (free the factor loading of the first indicator)
 ind60 =~ NA*x1 + x2 + x3
 dem60 =~ NA*y1 + y2 + y3 + y4
 dem65 =~ NA*y5 + y6 + y7 + y8

 #Regression paths
 dem60 ~ ind60
 dem65 ~ ind60 + dem60
 
 #Covariances among residual variances (correlated errors)
 y1 ~~ y5
 y2 ~~ y4 + y6
 y3 ~~ y7
 y4 ~~ y8
 y6 ~~ y8
 
 #Fix latent means to zero
 ind60 ~ 0
 dem60 ~ 0
 dem65 ~ 0
 
 #Fix latent variances to one
 ind60 ~~ 1*ind60
 dem60 ~~ 1*dem60
 dem65 ~~ 1*dem65
 
 #Estimate covariances among latent variables (not necessary because the latent variables are already linked via regression paths)
 
 #Estimate residual variances of manifest variables
 x1 ~~ x1
 x2 ~~ x2
 x3 ~~ x3
 y1 ~~ y1
 y2 ~~ y2
 y3 ~~ y3
 y4 ~~ y4
 y5 ~~ y5
 y6 ~~ y6
 y7 ~~ y7
 y8 ~~ y8
 
 #Free intercepts of manifest variables
 x1 ~ intx1*1
 x2 ~ intx2*1
 x3 ~ intx3*1
 y1 ~ inty1*1
 y2 ~ inty2*1
 y3 ~ inty3*1
 y4 ~ inty4*1
 y5 ~ inty5*1
 y6 ~ inty6*1
 y7 ~ inty7*1
 y8 ~ inty8*1
'
```

#### Model Syntax in Table Form: {#semModelTabular-sem}

```{r}
lavaanify(semModel_syntax)
lavaanify(semModel_fullSyntax)
```

### Fit the model {#semModelFit-sem}

```{r}
semModelFit <- sem(
  semModel_syntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR",
  std.lv = TRUE)

semModelFit_full <- lavaan(
  semModel_fullSyntax,
  data = PoliticalDemocracy,
  missing = "ML",
  estimator = "MLR")
```

### Display summary output {#semModelOutput-sem}

#### Interpreting `lavaan` output

```{r, include = FALSE}
library("MOTE")

chiSquareTestP <- fitMeasures(semModelFit,
                              fit.measures = "pvalue.scaled")
chiSquareTestBaselineP <- fitMeasures(semModelFit,
                                      fit.measures = "baseline.pvalue")
```

Output from a SEM model includes information such as regression coefficients, intercepts, variances, and model fit indices.\index{structural equation modeling!fit index}
As noted above, there are two chi-square tests.\index{structural equation modeling!fit index}
In `lavaan` syntax, one is labeled "Model Test User Model" and the other is labeled "Model Test Baseline Model."\index{structural equation modeling!fit index}
The chi-square test labeled "Model Test User Model" refers to the chi-square test of whether the model fits worse than the best-possible fitting model.\index{structural equation modeling!fit index}
In this case, the *p*-value of the robust chi-square test is $`r apa(chiSquareTestP, decimals = 2)`$.\index{structural equation modeling!fit index}
Thus, the model does not show significant misfit—i.e., the model does not fit significantly worse than the best-possible fitting model.\index{structural equation modeling!fit index}
The chi-square test labeled "Model Test Baseline Model" refers to the chi-square test of whether the model fits better than the worst-possible fitting model.\index{structural equation modeling!fit index}
In this case, the *p*-value of the robust chi-square test in comparison to the worse-possible fitting model is < .05.\index{structural equation modeling!fit index}
Thus, the model fits significantly better than the worst-possible-fitting model.\index{structural equation modeling!fit index}

In terms of the model findings, `ind60` was significantly positively associated with `dem60`, `dem60` was significantly positively associated with `dem65`, and `ind60` was marginally significantly positively associated with `dem65`.

```{r}
summary(
  semModelFit,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)

summary(
  semModelFit_full,
  fit.measures = TRUE,
  standardized = TRUE,
  rsquare = TRUE)
```

### Estimates of model fit {#semModelFitCriteria-sem}

```{r}
fitMeasures(
  semModelFit,
  fit.measures = c(
    "chisq", "df", "pvalue",
    "chisq.scaled", "df.scaled", "pvalue.scaled",
    "chisq.scaling.factor",
    "baseline.chisq","baseline.df","baseline.pvalue",
    "rmsea", "cfi", "tli", "srmr",
    "rmsea.robust", "cfi.robust", "tli.robust"))
```

### Residuals {#semModelResiduals-sem}

```{r}
residuals(semModelFit, type = "cor")
```

### Modification indices {#semModelModIndices-sem}

```{r}
modificationindices(semModelFit, sort. = TRUE)
```

### Factor scores {#semModelFactorScores-sem}

```{r}
semModelFit_factorScores <- lavPredict(semModelFit)
```

### Internal Consistency Reliability {#semModelReliability-sem}

[Internal consistency reliability](#internalConsistency-reliability) of items composing the latent factors, as quantified by [omega ($\omega$)](#coefficientOmega) and [average variance extracted](#averageVarianceExtracted) (AVE), was estimated using the `semTools` package [@R-semTools].\index{reliability!internal consistency!omega}\index{reliability!internal consistency!average variance extracted}

```{r}
compRelSEM(semModelFit)
AVE(semModelFit)
```

### Path diagram {#semModelPathDiagram-sem}

Below is a path diagram of the model generated using the `semPlot` package [@R-semPlot].

```{r, out.width = "100%", fig.align = "center", fig.cap = "Structural Equation Model."}
semPaths(
  semModelFit,
  what = "Std.all",
  layout = "tree2",
  edge.label.cex = 0.7)
```

## Benefits of SEM {#benefits-sem}

There are many benefits of fitting a model in SEM (or in other latent variable approaches).\index{structural equation modeling}\index{latent variable}
First, unlike [classical test theory](#ctt), SEM can allow correlated errors.
With SEM, you do not need to make as restrictive assumptions as in [classical test theory](#ctt).\index{classical test theory}\index{structural equation modeling}\index{structural equation modeling!residual!correlated}
Second, unlike multiple regression, SEM can handle multiple dependent variables simultaneously.\index{structural equation modeling}\index{multiple regression}
Third, SEM uses all available information (data) using a technique called full information maximum likelihood (FIML), even if participants have missing scores on some variables.\index{structural equation modeling}\index{missing data}
By contrast, multiple regression and many other statistical analyses use listwise deletion, in which they discard participants if they have a missing score on any of the model variables.\index{multiple regression}\index{missing data}
Fourth, as described in the next section (\@ref(semMethodBias)), SEM can be used to account for different forms of [measurement error](#measurementError) (e.g., [method bias](#methodBias)).\index{structural equation modeling}\index{measurement error}\index{method bias}
Accounting for [measurement error](#measurementError) allows [disattenuating](#disattenuation) associations with other constructs.\index{structural equation modeling}\index{measurement error}\index{method bias}\index{association!disattenuation of}
I provide an example showing that SEM disattenuates associations for [measurement error](#measurementError) in Section \@ref(disattenuation).\index{structural equation modeling}\index{measurement error}\index{method bias}\index{association!disattenuation of}\index{measurement error!disattenuation of association}
All of these benefits allow SEM to generate purer estimation of constructs, more accurate estimates of people's levels on constructs, and more accurate estimates of associations between constructs.\index{structural equation modeling}\index{measurement error}

### Accounting for Method Bias {#semMethodBias}

SEM/[CFA](#cfa) can be used to account for [method biases](#methodBias) and other forms of [measurement error](#measurementError).\index{structural equation modeling}\index{measurement error}\index{method bias}
You can use indicators that reflect different [method biases](#methodBias), so that the [method biases](#methodBias) are discarded as unique [errors](#measurementError), and are not combined in the "common variance" of the latent construct.\index{structural equation modeling}\index{measurement error}\index{method bias}
SEM/[CFA](#cfa) can be used to fit a [multitrait-multimethod matrix](#MTMM) to account for method variance.\index{structural equation modeling}\index{measurement error}\index{method variance}\index{multitrait-multimethod matrix}
I provide an example of fitting a [multitrait-multimethod matrix](#MTMM) in [CFA](#cfa) in Sections \@ref(mtmmCFA-validity) and \@ref(mtmmCFA).\index{factor analysis!confirmatory}\index{multitrait-multimethod matrix}
But estimation of a [multitrait-multimethod matrit](#MTMM) in [CFA](#cfa) can be challenging without making additional constraints/assumptions.\index{factor analysis!confirmatory}\index{multitrait-multimethod matrix}

A more practical utility of SEM is that allows one to obtain "purer" estimates of latent constructs (and people's standing on them) by discarding [measurement error](#measurementError), and you do not have to assume all [errors](#measurementError) are uncorrelated!\index{structural equation modeling}\index{measurement error}

## Generalizability Theory {#generalizability-SEM}

There are also SEM approaches for performing [generalizability theory](#gTheory) analyses.\index{generalizability theory}\index{structural equation modeling}
The reader is referred to examples by @Vispoel2018, @Vispoel2019, @Vispoel2022, and @Vispoel2023.\index{generalizability theory}\index{structural equation modeling}

## Conclusion {#conclusion-sem}

Structural equation modeling (SEM) is an advanced modeling approach that allows estimating latent variables as the common variance from multiple measures.\index{structural equation modeling}\index{latent variable}\index{aggregation}
SEM holds promise to account for [measurement error](#measurementError) and [method biases](#methodBias), which allows one to get more accurate estimates of constructs, people's standing on constructs (i.e., individual differences), and associations between constructs.\index{structural equation modeling}\index{measurement error}\index{method bias}

## Suggested Readings {#readings-sem}

@MacCallum2000

## Exercises {#semExercises}

```{r, include = FALSE}
library("MOTE")
```

```{r, include = FALSE}
# Load Data ---------------------------------------------------------------

cnlsy <- read_csv(here("Data", "cnlsy.csv"))
```

```{r, include = FALSE}
# Measurement Model

## Specify the model
measurementModelT1 <- '
 #Factor loadings
 antisocialT1 =~ bpi_antisocialT1_1 + bpi_antisocialT1_2 + bpi_antisocialT1_3 + bpi_antisocialT1_4 + bpi_antisocialT1_5 + bpi_antisocialT1_6 + bpi_antisocialT1_7
'
```

```{r, include = FALSE}
measurementModelT2 <- '
 #Factor loadings
 antisocialT2 =~ bpi_antisocialT2_1 + bpi_antisocialT2_2 + bpi_antisocialT2_3 + bpi_antisocialT2_4 + bpi_antisocialT2_5 + bpi_antisocialT2_6 + bpi_antisocialT2_7
'
```

```{r, include = FALSE}
### Summary of Model Features
summary(measurementModelT1)

### Model Syntax in Table Form:
lavaanify(measurementModelT1)
```

```{r, include = FALSE}
## Fit the model
measurementModel1Fit <- cfa(measurementModelT1,
                            data = cnlsy,
                            missing = "ML",
                            estimator = "MLR")

measurementModel2Fit <- cfa(measurementModelT2,
                            data = cnlsy,
                            missing = "ML",
                            estimator = "MLR")
```

```{r, include = FALSE}
## Display summary output
summary(measurementModel1Fit,
        fit.measures = TRUE,
        standardized = TRUE,
        rsquare = TRUE)

summary(measurementModel2Fit,
        fit.measures = TRUE,
        standardized = TRUE,
        rsquare = TRUE)
```

```{r, include = FALSE}
fitMeasures(measurementModel1Fit,
            fit.measures = c("chisq", "df", "pvalue",
                             "chisq.scaled", "df.scaled", "pvalue.scaled",
                             "chisq.scaling.factor",
                             "rmsea", "cfi", "tli", "srmr",
                             "rmsea.robust", "cfi.robust", "tli.robust"))

measurementModel1ChiSquare <- fitMeasures(measurementModel1Fit, fit.measures = c("chisq.scaled"))
measurementModel1DF <- fitMeasures(measurementModel1Fit, fit.measures = c("df.scaled"))

measurementModel1RMSEA <- fitMeasures(measurementModel1Fit, fit.measures = c("rmsea"))
measurementModel1CFI <- fitMeasures(measurementModel1Fit, fit.measures = c("cfi"))
measurementModel1SRMR <- fitMeasures(measurementModel1Fit, fit.measures = c("srmr"))
```

```{r, include = FALSE}
## Modification indices
modificationindices(measurementModel1Fit, sort. = TRUE)
modificationindices(measurementModel2Fit, sort. = TRUE)
```

```{r, include = FALSE}
## Reliability
compRelSEM(measurementModel1Fit)
AVE(measurementModel1Fit)
```

```{r, include = FALSE}
## Path Diagram
semPaths(measurementModel1Fit,
         what = "Std.all",
         layout = "tree2",)
```

```{r, include = FALSE}
# Correlated Errors -------------------------------------------------------

## Specify the model
measurementModelCorrelatedErrorsT1 <- '
 #Factor loadings
 antisocialT1 =~ bpi_antisocialT1_1 + bpi_antisocialT1_2 + bpi_antisocialT1_3 + 
  bpi_antisocialT1_4 + bpi_antisocialT1_5 + bpi_antisocialT1_6 + 
  bpi_antisocialT1_7
 
 #Correlated errors
 bpi_antisocialT1_5 ~~ bpi_antisocialT1_6
'
```

```{r, include = FALSE}
measurementModelCorrelatedErrorsT2 <- '
 #Factor loadings
 antisocialT2 =~ bpi_antisocialT2_1 + bpi_antisocialT2_2 + bpi_antisocialT2_3 + 
  bpi_antisocialT2_4 + bpi_antisocialT2_5 + bpi_antisocialT2_6 + 
  bpi_antisocialT2_7

 #Correlated errors
 bpi_antisocialT2_5 ~~ bpi_antisocialT2_6
'
```

```{r, include = FALSE}
### Summary of Model Features
summary(measurementModelCorrelatedErrorsT1)

### Model Syntax in Table Form:
lavaanify(measurementModelCorrelatedErrorsT1)
```

```{r, include = FALSE}
## Fit the model
measurementModelCorrelatedErrors1Fit <- cfa(measurementModelCorrelatedErrorsT1,
                            data = cnlsy,
                            missing = "ML",
                            estimator = "MLR")

measurementModelCorrelatedErrors2Fit <- cfa(measurementModelCorrelatedErrorsT2,
                            data = cnlsy,
                            missing = "ML",
                            estimator = "MLR")
```

```{r, include = FALSE}
## Display summary output
summary(measurementModelCorrelatedErrors1Fit,
        fit.measures = TRUE,
        standardized = TRUE,
        rsquare = TRUE)

summary(measurementModelCorrelatedErrors2Fit,
        fit.measures = TRUE,
        standardized = TRUE,
        rsquare = TRUE)
```

```{r, include = FALSE}
## Factor loadings
measurementModelCorrelatedErrors1FitFactorLoadingStd <- standardizedSolution(measurementModelCorrelatedErrors1Fit)
measurementModelCorrelatedErrors1FitFactorLoadingStdItem2 <- measurementModelCorrelatedErrors1FitFactorLoadingStd$est.std[which(measurementModelCorrelatedErrors1FitFactorLoadingStd$lhs == "antisocialT1" & measurementModelCorrelatedErrors1FitFactorLoadingStd$rhs == "bpi_antisocialT1_2")]
measurementModelCorrelatedErrors1FitFactorLoadingStdItem7 <- measurementModelCorrelatedErrors1FitFactorLoadingStd$est.std[which(measurementModelCorrelatedErrors1FitFactorLoadingStd$lhs == "antisocialT1" & measurementModelCorrelatedErrors1FitFactorLoadingStd$rhs == "bpi_antisocialT1_7")]
```

```{r, include = FALSE}
## Modification indices
modificationindices(measurementModelCorrelatedErrors1Fit, sort. = TRUE)
modificationindices(measurementModelCorrelatedErrors2Fit, sort. = TRUE)
```

```{r, include = FALSE}
## Factor scores
measurementModelCorrelatedErrors1Fit_factorScores <- lavPredict(measurementModelCorrelatedErrors1Fit)

## Reliability
measurementModelCorrelatedErrors1Omega <- compRelSEM(measurementModelCorrelatedErrors1Fit)
```

```{r, include = FALSE}
## Path Diagram
semPaths(measurementModelCorrelatedErrors1Fit,
         what = "Std.all",
         layout = "tree2",
         edge.label.cex = 1.1)
```

```{r, include = FALSE}
fitMeasures(measurementModelCorrelatedErrors1Fit, fit.measures = c("chisq", "df", "pvalue",
                                                   "chisq.scaled", "df.scaled", "pvalue.scaled",
                                                   "chisq.scaling.factor",
                                                   "rmsea", "cfi", "tli", "srmr",
                                                   "rmsea.robust", "cfi.robust", "tli.robust"))

measurementModelCorrelatedErrors1ChiSquare <- fitMeasures(measurementModelCorrelatedErrors1Fit, fit.measures = c("chisq.scaled"))
measurementModelCorrelatedErrors1DF <- fitMeasures(measurementModelCorrelatedErrors1Fit, fit.measures = c("df.scaled"))

measurementModelCorrelatedErrors1RMSEA <- fitMeasures(measurementModelCorrelatedErrors1Fit, fit.measures = c("rmsea"))
measurementModelCorrelatedErrors1CFI <- fitMeasures(measurementModelCorrelatedErrors1Fit, fit.measures = c("cfi"))
measurementModelCorrelatedErrors1SRMR <- fitMeasures(measurementModelCorrelatedErrors1Fit, fit.measures = c("srmr"))
```


```{r, include = FALSE}
measurementModelComparison <- anova(measurementModel1Fit, measurementModelCorrelatedErrors1Fit)

measurementModelChiSquareDiff <- measurementModelComparison$"Chisq diff"[2]
measurementModelDFDiff <- measurementModelComparison$"Df diff"[2]
```

```{r, include = FALSE}
# SEM ---------------------------------------------------------------------

## Specify the model
semModel_ex <- '
 #Factor loadings
 antisocialT1 =~ bpi_antisocialT1_1 + bpi_antisocialT1_2 + bpi_antisocialT1_3 + bpi_antisocialT1_4 + bpi_antisocialT1_5 + bpi_antisocialT1_6 + bpi_antisocialT1_7
 antisocialT2 =~ bpi_antisocialT2_1 + bpi_antisocialT2_2 + bpi_antisocialT2_3 + bpi_antisocialT2_4 + bpi_antisocialT2_5 + bpi_antisocialT2_6 + bpi_antisocialT2_7

 #Correlated errors
 bpi_antisocialT1_5 ~~ bpi_antisocialT1_6
 bpi_antisocialT2_5 ~~ bpi_antisocialT2_6
'
```

```{r, include = FALSE}
### Summary of Model Features
summary(semModel_ex)

### Model Syntax in Table Form:
lavaanify(semModel_ex)
```

```{r, include = FALSE}
## Fit the model
semModelFit_ex <- cfa(semModel_ex,
                   data = cnlsy,
                   missing = "ML",
                   estimator = "MLR",
                   std.lv = TRUE)
```

```{r, include = FALSE}
## Display summary output
summary(semModelFit_ex,
        fit.measures = TRUE,
        standardized = TRUE,
        rsquare = TRUE)
```

```{r, include = FALSE}
semModelFactorLoadingStd_ex <- standardizedSolution(semModelFit_ex)

correlationLatentFactor <- semModelFactorLoadingStd_ex$est.std[which(semModelFactorLoadingStd_ex$lhs == "antisocialT1" & semModelFactorLoadingStd_ex$rhs == "antisocialT2")]
```

```{r, include = FALSE}
## Modification indices
modificationindices(semModelFit_ex, sort. = TRUE)

## Factor scores
semModelFit_ex_factorScores <- lavPredict(semModelFit_ex)

## Reliability
compRelSEM(semModelFit_ex)
AVE(semModelFit_ex)
```

```{r, include = FALSE}
## Path Diagram
semPaths(semModelFit_ex,
         what = "Std.all",
         layout = "tree2",
         edge.label.cex = 0.6)
```

```{r, include = FALSE}
correlationSumScores <- cor.test(x = cnlsy$bpi_antisocialT1Sum, y = cnlsy$bpi_antisocialT2Sum)$estimate
```

```{r, include = FALSE}
semModel2 <- '
 #Factor loadings
 antisocialT1 =~ bpi_antisocialT1_1 + bpi_antisocialT1_2 + bpi_antisocialT1_3 + bpi_antisocialT1_4 + bpi_antisocialT1_5 + bpi_antisocialT1_6 + bpi_antisocialT1_7
 antisocialT2 =~ bpi_antisocialT2_1 + bpi_antisocialT2_2 + bpi_antisocialT2_3 + bpi_antisocialT2_4 + bpi_antisocialT2_5 + bpi_antisocialT2_6 + bpi_antisocialT2_7

 #Correlated errors
 bpi_antisocialT1_5 ~~ bpi_antisocialT1_6
 bpi_antisocialT2_5 ~~ bpi_antisocialT2_6
 
 #Regression path
 antisocialT2 ~ antisocialT1 + bpi_anxiousDepressedSum
'
```

```{r, include = FALSE}
## Fit the model
semModel2Fit <- cfa(semModel2,
                   data = cnlsy,
                   missing = "ML",
                   estimator = "MLR",
                   std.lv = TRUE,
                   fixed.x = FALSE)
```

```{r, include = FALSE}
## Display summary output
summary(semModel2Fit,
        fit.measures = TRUE,
        standardized = TRUE,
        rsquare = TRUE)
```

```{r, include = FALSE}
semModel2Unstd <- parameterEstimates(semModel2Fit, standardized = FALSE)
semModel2Std <- parameterEstimates(semModel2Fit, standardized = TRUE)

semModel2UnstdB <- semModel2Unstd$est[which(semModel2Unstd$lhs == "antisocialT2" & semModel2Unstd$rhs == "bpi_anxiousDepressedSum")]
semModel2UnstdSE <- semModel2Unstd$se[which(semModel2Unstd$lhs == "antisocialT2" & semModel2Unstd$rhs == "bpi_anxiousDepressedSum")]
semModel2StdBeta <- semModel2Std$std.all[which(semModel2Std$lhs == "antisocialT2" & semModel2Std$rhs == "bpi_anxiousDepressedSum")]
```

### Questions

Note: Several of the following questions use data from the Children of the National Longitudinal Survey of Youth Survey (CNLSY).
The CNLSY is a publicly available longitudinal data set provided by the Bureau of Labor Statistics (https://www.bls.gov/nls/nlsy79-children.htm#topical-guide; archived at https://perma.cc/EH38-HDRN).
The CNLSY data file for these exercises is located on the book's page of the Open Science Framework (https://osf.io/3pwza).
Children's behavior problems were rated in 1988 (time 1: T1) and then again in 1990 (time 2: T2) on the Behavior Problems Index (BPI).
Below are the items corresponding to the Antisocial subscale of the BPI:

1) cheats or tells lies
2) bullies or is cruel/mean to others
3) does not seem to feel sorry after misbehaving
4) breaks things deliberately
5) is disobedient at school
6) has trouble getting along with teachers
7) has sudden changes in mood or feeling

1. Fit a confirmatory factor analysis model to the seven items of the Antisocial subscale of the Behavior Problems Index at T1.
Set the first indicator to be the referent indicator (to set the scale of the latent factor) by setting its loading to one.
Allow the factor loadings of the other indicators to be freely estimated.
Set the mean (intercept) of the latent factor to be zero.
Do not allow the residuals to be correlated.
Use full information maximum likelihood (FIML) to account for missing data.
Use robust standard errors to account for non-normally distributed data.
    a. This is an over-simplification, but for now let us assume a model fits "well" if CFI $\geq .95$, RMSEA $< .08$, and SRMR $< .08$ [@Schreiber2006].
    Did the model fit well?
    What does this indicate?
    b. Examine the modification indices.
    Which modification would result in the greatest improvement in model fit?
    Why do you think this modification would improve model fit?
2. Fit the modified confirmatory factor analysis model to make the suggested revision you identified in `1b`.
    a. Provide a figure of the model with standardized coefficients.
    b. The modified model and the original model are considered "nested" models.
    The original model is nested within the modified model because the modified model includes all of the terms of the original model along with additional terms.
    Model fit of nested models can be directly compared with a chi-square difference test.
    Did the modified model fit better than the original model?
    c. Did the modified model fit well?
    What does this indicate?
    Which item is most strongly with the latent factor?
    Which item is most weakly associated with the latent factor?
    d. What is the estimate of internal consistency reliability of the items, based on coefficient omega?
3. Fit a confirmatory factor analysis model to the seven items of the Antisocial subscale of the Behavior Problems Index at both T1 and T2 simultaneously in the same model.
Allow the items at T1 to load onto a different factor than the items at T2 (i.e., a two-factor model—one antisocial at each time point).
Set the scale of the latent factors by standardizing the latent factors—set their means to one and their variances to zero.
This allows you to freely estimate the factor loadings of all items (instead of setting a reference indicator).
Estimate the covariance between the two latent factors.
Treat exogenous covariates as random variables (whose means, variances, and covariances are estimated) by specifying `fixed.x = FALSE`.
Use full information maximum likelihood (FIML) to account for missing data.
Use robust standard errors to account for non-normally distributed data.
Apply the same modification you noted in 1b above to each factor.
    a. Because the two latent factors are standardized, the "covariance" path between the two latent factors represents a correlation.
    What is the correlation between the latent factors?
    What is the correlation between the sum scores (`bpi_antisocialT1Sum`, `bpi_antisocialT2Sum`)?
    Which is greater and why?
    b. Change the covariance path to a regression path from the latent factor at T1 predicting the latent factor at T2.
    Also include the sum score of anxious/depressed symptoms at T1 (`bpi_anxiousDepressedSum`) as a predictor of antisocial behavior at T2.
    Do anxious/depressed symptoms at T1 predict antisocial behavior at T2 controlling for prior levels of antisocial behavior at T1?
    Interpret the findings.

### Answers

1.
    a. The model did not fit well according to CFI $(`r apa(measurementModel1CFI, decimals = 2)`)$ and RMSEA $(`r apa(measurementModel1RMSEA, decimals = 2)`)$.
	SRMR $(`r apa(measurementModel1SRMR, decimals = 2)`)$ was acceptable.
	The poor model fit indicates that it is unlikely that the causal process described by the hypothesized model gave rise to the observed data.
    b. The modification that would result in the greatest model fit according to the modification indices is to allow indicators 5 and 6 to be correlated.
	These indicators reflect "disobedience at school" and "trouble getting along with teachers," respectively.
	It is likely that allowing these two residuals to correlate would improve model fit because they both assess children's behavior in the school context, and so they would continue to be associated with each other even after accounting for variance from the latent factor.
2.
    a.
    
```{r semFigureAnswer, out.width = "100%", fig.align = "center", fig.cap = "Figure of the Confirmatory Factor Analysis Model With Standardized Coefficients.", echo = FALSE}
semPaths(measurementModelCorrelatedErrors1Fit,
         what = "Std.all",
         layout = "tree2",
         edge.label.cex = 1.1)
```

2.
    b. The modified model $(\chi^2[df = `r measurementModelCorrelatedErrors1DF`] = `r apa(measurementModelCorrelatedErrors1ChiSquare, decimals = 2)`)$ fit significantly better than the original model $(\chi^2[df = `r measurementModel1DF`] = `r apa(measurementModel1ChiSquare, decimals = 2)`)$ according to a chi-square difference test $(\Delta\chi^2[df = `r measurementModelDFDiff`] = `r apa(measurementModelChiSquareDiff, decimals = 2)`, p < .001)$.
    c. The model fit well according to CFI $(`r measurementModelCorrelatedErrors1CFI`)$, RMSEA $(`r measurementModelCorrelatedErrors1RMSEA`)$, and SRMR $(`r measurementModelCorrelatedErrors1SRMR`)$.
	This indicates that there is evidence that one factor may do a good job of explaining the covariance among the indicators, especially when allowing the residuals of items 5 and 6 to correlate.
	The item that shows the strongest association with the latent factor is item 2 ("bullies or is cruel/mean to others": standardized factor loading = $`r apa(measurementModelCorrelatedErrors1FitFactorLoadingStdItem2, decimals = 2, leading = FALSE)`$).
	The item that shows the weakest association with the latent factor is item 7 ("sudden changes in mood or feeling": standardized factor loading = $`r apa(measurementModelCorrelatedErrors1FitFactorLoadingStdItem7, decimals = 2, leading = FALSE)`$).
	Thus, meanness seems more core to the construct of antisocial behavior compared to sudden mood changes.
    d. The estimate of internal consistency reliability of items, based on coefficient omega ($\omega$), is $`r apa (measurementModelCorrelatedErrors1Omega, decimals = 2, leading = FALSE)`$.
3.
    a. The correlation between the latent factor at T1 and T2 is $\phi = `r apa(correlationLatentFactor, decimals = 2, leading = FALSE)`$.
	The correlation between the sum score at T1 and T2 is $r = `r apa(correlationSumScores, decimals = 2, leading = FALSE)`$.
	This indicates that the correlation of individual differences across time (rank-order stability) is stronger for the latent factor than for the sum scores.
	This is likely because the latent factors account for measurement error whereas the sum scores do not, and associations are attenuated due to measurement error.
	Thus, the association of the latent factor at T1 and T2 likely more accurately reflects the "true" cross-time association of the construct (compared to the association of the sum scores at T1 and T2).
	b. Yes, anxious/depressed symptoms significantly predicted antisocial behavior at T2 while controlling for prior levels of antisocial behavior $(B = `r apa(semModel2UnstdB, decimals = 2)`, β = `r apa(semModel2StdBeta, decimals = 2, leading = FALSE)`, SE = `r apa(semModel2UnstdSE, decimals = 2)`, p < .001)$.
	That is, anxious/depressed symptoms predicted relative (rank-order) changes in antisocial behavior from T1 to T2.
	This suggests that anxiety/depression may be a pathway to antisocial behavior for some children.
	Because the data come from an observational design, however, we cannot infer causality.
	For instance, the association could owe to the opposite direction of effect (antisocial behavior could lead to anxiety/depression) or to a third variable (e.g., victimization could lead to both antisocial behavior and anxiety/depression; i.e., antisocial behavior and anxiety/depression could share a common cause).
